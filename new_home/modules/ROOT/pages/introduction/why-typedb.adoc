= Why TypeDB?

TypeDB offers developers a new way to manage their data, with simplicity, safety, and expressivity at the forefront.

== Why do we need something new?

Relational, document, and graph databases are the dominant general-purpose database models today.
While these are powerful tools, they often make your life harder by pushing problems of data safety, expressivity, and evolution back to you.

TypeDB was designed specifically to overcome these limitations, while borrowing some of their best ideas like strict schemas and easy-to-read query languages.
By using a higher-level model based on entities, relations, and attributes, you'll never deal with normalization, joins, foreign keys, nulls, or missing data again.

TypeDB and TypeQL are grounded in a rigorous mathematical model called PERA (Polymorphic Entity, Relation, Attribute), with a peer-reviewed foundation in type theory.
You can find our [published paper](https://typedb.com/papers/typeql-theory) online.
This foundation means that TypeDB's development will always move forward in a mathematically sound and principled way that continues to improve developer experience.

Developers need a database that will save them time, money, and effort.
TypeDB allows you to spend less time on database design, query debugging, schema migrations, and worrying about data correctness,
and more time on application development and business logic.

== Key reasons to choose TypeDB

There are many reasons developers love TypeDB. Here are a few of the top ones:

=== Ease of use

TypeDB combines an xref:{page-version}@new_core_concepts::typedb/typeql.adoc[intuitive query language], 
and a simple set of xref:{page-version}@new_core_concepts::typedb/index.adoc[database concepts],
and the option to use a [fully managed service](https://cloud.typedb.com) — that includes certificate management, backups, and more.

TypeDB's data model can also capture much more of your domain than relational databases can:
polymorphism and native support for subtyping help close the object-relational gap that persists between
most databases and their application code.

You'll also never need a semantic layer to enforce your data model:
types you define in TypeDB's schema serve as a semantic layer by themselves — with no extra work from you!

=== Powerful modelling

TypeDB's baseline types are xref:{page-version}@new_core_concepts::typedb/entities-relations-attributes.adoc[Entities, Relations, and Attributes].
These can be combined in countless ways to capture your domain accurately.

To help with this, TypeDB supports many modifiers and uses of these basic types, for example:

- **Subtyping**: create sub-entities, relations, or even attributes that have the capabilities of all their supertypes
- **Hyper-relations**: not only can you connect relationships with any number of entities, you can also nest them within other relations
- **Variadic relations**: roles in relations can be filled multiple times, and different roles can even be filled by the same participant
- **Multivalued attributes**: entities and relations can have multiple instances of the same attribute with different values
- **Cardinality constraints**: configurable limits on the number of attributes, relations, or entities to connect to

You can even create reusable xref:{page-version}@new_core_concepts::typedb/queries-as-functions.adoc[functions] to capture modular pieces of database logic and invoke them at query time.

Put together, TypeDB can capture the most complex data models, while being easy to extend with new types and relationships as your application grows.

=== Safety

TypeDB's users frequently work in domains that might normally require extensive application logic to validate their data.

TypeDB's type system ensures that you can push more data constraints into the database. TypeDB automatically ensures
that your inserted data conforms to the required relationships, value types, cardinalities, value ranges, and more.

Even during pure read operations, TypeDB's type inference engine will reject semantically invalid operations.
This allows developers to distinguish an **invalid query returning no results**, which would return an error in TypeDB,
from a **query correctly returning no results**.

Combined with xref:{page-version}@new_core_concepts::typedb/transactions.adoc[transactions], you can be confident of moving between correct states. Even better,
schema and data can be mutated together in one schema transaction, with full commit-time validation, making migrations
safe and easy.

== Choosing TypeDB

TypeDB is commonly deployed in the following areas:

- **Complex, highly interconnected data:** Think of domains like cybersecurity, life sciences, financial fraud detection, or supply chain management.
- **Enforce strict data integrity and consistency:** The strong typing and schema ensure your data adheres to your defined rules.
- **Handle evolving data models:** The polymorphic nature and schema capabilities make it easier to adapt your data model as your understanding of the domain grows.
- **Build intelligent systems:** TypeDB provides an excellent data layer for AI and machine learning applications that require a deep understanding of relationships with built-in guardrails.

But it even suits simple applications that need to capture things like subtyping relationships!
Whatever your domain, TypeDB has the expressivity and capabilities to capture it intuitively.

Feel free to explore our xref:{page-version}@new_home::examples.adoc[Examples and use cases] to get a feel for how some TypeDB applications can look.

== Next steps

Check out our xref:{page-version}@new_home::learning_journey.adoc[Learning Journey] for a guided path through the documentation,
or jump into the xref:{page-version}@new_home::quickstart/setup.adoc[quickstart].